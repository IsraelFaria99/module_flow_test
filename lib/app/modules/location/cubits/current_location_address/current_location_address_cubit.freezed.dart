// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'current_location_address_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$CurrentLocationAddressStateTearOff {
  const _$CurrentLocationAddressStateTearOff();

// ignore: unused_element
  CurrentLocationAddressInitial initial() {
    return const CurrentLocationAddressInitial();
  }

// ignore: unused_element
  CurrentLocationAddressLoadInProgress loadInProgress() {
    return const CurrentLocationAddressLoadInProgress();
  }

// ignore: unused_element
  CurrentLocationAddressLoadSuccess loadSuccess(LocationModel location) {
    return CurrentLocationAddressLoadSuccess(
      location,
    );
  }

// ignore: unused_element
  CurrentLocationAddressLoadFailure loadFailure() {
    return const CurrentLocationAddressLoadFailure();
  }
}

/// @nodoc
// ignore: unused_element
const $CurrentLocationAddressState = _$CurrentLocationAddressStateTearOff();

/// @nodoc
mixin _$CurrentLocationAddressState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(LocationModel location),
    @required Result loadFailure(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(LocationModel location),
    Result loadFailure(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(CurrentLocationAddressInitial value),
    @required Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    @required Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    @required Result loadFailure(CurrentLocationAddressLoadFailure value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(CurrentLocationAddressInitial value),
    Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    Result loadFailure(CurrentLocationAddressLoadFailure value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $CurrentLocationAddressStateCopyWith<$Res> {
  factory $CurrentLocationAddressStateCopyWith(
          CurrentLocationAddressState value,
          $Res Function(CurrentLocationAddressState) then) =
      _$CurrentLocationAddressStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$CurrentLocationAddressStateCopyWithImpl<$Res>
    implements $CurrentLocationAddressStateCopyWith<$Res> {
  _$CurrentLocationAddressStateCopyWithImpl(this._value, this._then);

  final CurrentLocationAddressState _value;
  // ignore: unused_field
  final $Res Function(CurrentLocationAddressState) _then;
}

/// @nodoc
abstract class $CurrentLocationAddressInitialCopyWith<$Res> {
  factory $CurrentLocationAddressInitialCopyWith(
          CurrentLocationAddressInitial value,
          $Res Function(CurrentLocationAddressInitial) then) =
      _$CurrentLocationAddressInitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$CurrentLocationAddressInitialCopyWithImpl<$Res>
    extends _$CurrentLocationAddressStateCopyWithImpl<$Res>
    implements $CurrentLocationAddressInitialCopyWith<$Res> {
  _$CurrentLocationAddressInitialCopyWithImpl(
      CurrentLocationAddressInitial _value,
      $Res Function(CurrentLocationAddressInitial) _then)
      : super(_value, (v) => _then(v as CurrentLocationAddressInitial));

  @override
  CurrentLocationAddressInitial get _value =>
      super._value as CurrentLocationAddressInitial;
}

/// @nodoc
class _$CurrentLocationAddressInitial implements CurrentLocationAddressInitial {
  const _$CurrentLocationAddressInitial();

  @override
  String toString() {
    return 'CurrentLocationAddressState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CurrentLocationAddressInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(LocationModel location),
    @required Result loadFailure(),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(LocationModel location),
    Result loadFailure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(CurrentLocationAddressInitial value),
    @required Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    @required Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    @required Result loadFailure(CurrentLocationAddressLoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(CurrentLocationAddressInitial value),
    Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    Result loadFailure(CurrentLocationAddressLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class CurrentLocationAddressInitial
    implements CurrentLocationAddressState {
  const factory CurrentLocationAddressInitial() =
      _$CurrentLocationAddressInitial;
}

/// @nodoc
abstract class $CurrentLocationAddressLoadInProgressCopyWith<$Res> {
  factory $CurrentLocationAddressLoadInProgressCopyWith(
          CurrentLocationAddressLoadInProgress value,
          $Res Function(CurrentLocationAddressLoadInProgress) then) =
      _$CurrentLocationAddressLoadInProgressCopyWithImpl<$Res>;
}

/// @nodoc
class _$CurrentLocationAddressLoadInProgressCopyWithImpl<$Res>
    extends _$CurrentLocationAddressStateCopyWithImpl<$Res>
    implements $CurrentLocationAddressLoadInProgressCopyWith<$Res> {
  _$CurrentLocationAddressLoadInProgressCopyWithImpl(
      CurrentLocationAddressLoadInProgress _value,
      $Res Function(CurrentLocationAddressLoadInProgress) _then)
      : super(_value, (v) => _then(v as CurrentLocationAddressLoadInProgress));

  @override
  CurrentLocationAddressLoadInProgress get _value =>
      super._value as CurrentLocationAddressLoadInProgress;
}

/// @nodoc
class _$CurrentLocationAddressLoadInProgress
    implements CurrentLocationAddressLoadInProgress {
  const _$CurrentLocationAddressLoadInProgress();

  @override
  String toString() {
    return 'CurrentLocationAddressState.loadInProgress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CurrentLocationAddressLoadInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(LocationModel location),
    @required Result loadFailure(),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(LocationModel location),
    Result loadFailure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(CurrentLocationAddressInitial value),
    @required Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    @required Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    @required Result loadFailure(CurrentLocationAddressLoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(CurrentLocationAddressInitial value),
    Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    Result loadFailure(CurrentLocationAddressLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress(this);
    }
    return orElse();
  }
}

abstract class CurrentLocationAddressLoadInProgress
    implements CurrentLocationAddressState {
  const factory CurrentLocationAddressLoadInProgress() =
      _$CurrentLocationAddressLoadInProgress;
}

/// @nodoc
abstract class $CurrentLocationAddressLoadSuccessCopyWith<$Res> {
  factory $CurrentLocationAddressLoadSuccessCopyWith(
          CurrentLocationAddressLoadSuccess value,
          $Res Function(CurrentLocationAddressLoadSuccess) then) =
      _$CurrentLocationAddressLoadSuccessCopyWithImpl<$Res>;
  $Res call({LocationModel location});
}

/// @nodoc
class _$CurrentLocationAddressLoadSuccessCopyWithImpl<$Res>
    extends _$CurrentLocationAddressStateCopyWithImpl<$Res>
    implements $CurrentLocationAddressLoadSuccessCopyWith<$Res> {
  _$CurrentLocationAddressLoadSuccessCopyWithImpl(
      CurrentLocationAddressLoadSuccess _value,
      $Res Function(CurrentLocationAddressLoadSuccess) _then)
      : super(_value, (v) => _then(v as CurrentLocationAddressLoadSuccess));

  @override
  CurrentLocationAddressLoadSuccess get _value =>
      super._value as CurrentLocationAddressLoadSuccess;

  @override
  $Res call({
    Object location = freezed,
  }) {
    return _then(CurrentLocationAddressLoadSuccess(
      location == freezed ? _value.location : location as LocationModel,
    ));
  }
}

/// @nodoc
class _$CurrentLocationAddressLoadSuccess
    implements CurrentLocationAddressLoadSuccess {
  const _$CurrentLocationAddressLoadSuccess(this.location)
      : assert(location != null);

  @override
  final LocationModel location;

  @override
  String toString() {
    return 'CurrentLocationAddressState.loadSuccess(location: $location)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CurrentLocationAddressLoadSuccess &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(location);

  @override
  $CurrentLocationAddressLoadSuccessCopyWith<CurrentLocationAddressLoadSuccess>
      get copyWith => _$CurrentLocationAddressLoadSuccessCopyWithImpl<
          CurrentLocationAddressLoadSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(LocationModel location),
    @required Result loadFailure(),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(location);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(LocationModel location),
    Result loadFailure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(location);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(CurrentLocationAddressInitial value),
    @required Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    @required Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    @required Result loadFailure(CurrentLocationAddressLoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(CurrentLocationAddressInitial value),
    Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    Result loadFailure(CurrentLocationAddressLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(this);
    }
    return orElse();
  }
}

abstract class CurrentLocationAddressLoadSuccess
    implements CurrentLocationAddressState {
  const factory CurrentLocationAddressLoadSuccess(LocationModel location) =
      _$CurrentLocationAddressLoadSuccess;

  LocationModel get location;
  $CurrentLocationAddressLoadSuccessCopyWith<CurrentLocationAddressLoadSuccess>
      get copyWith;
}

/// @nodoc
abstract class $CurrentLocationAddressLoadFailureCopyWith<$Res> {
  factory $CurrentLocationAddressLoadFailureCopyWith(
          CurrentLocationAddressLoadFailure value,
          $Res Function(CurrentLocationAddressLoadFailure) then) =
      _$CurrentLocationAddressLoadFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$CurrentLocationAddressLoadFailureCopyWithImpl<$Res>
    extends _$CurrentLocationAddressStateCopyWithImpl<$Res>
    implements $CurrentLocationAddressLoadFailureCopyWith<$Res> {
  _$CurrentLocationAddressLoadFailureCopyWithImpl(
      CurrentLocationAddressLoadFailure _value,
      $Res Function(CurrentLocationAddressLoadFailure) _then)
      : super(_value, (v) => _then(v as CurrentLocationAddressLoadFailure));

  @override
  CurrentLocationAddressLoadFailure get _value =>
      super._value as CurrentLocationAddressLoadFailure;
}

/// @nodoc
class _$CurrentLocationAddressLoadFailure
    implements CurrentLocationAddressLoadFailure {
  const _$CurrentLocationAddressLoadFailure();

  @override
  String toString() {
    return 'CurrentLocationAddressState.loadFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CurrentLocationAddressLoadFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initial(),
    @required Result loadInProgress(),
    @required Result loadSuccess(LocationModel location),
    @required Result loadFailure(),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initial(),
    Result loadInProgress(),
    Result loadSuccess(LocationModel location),
    Result loadFailure(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initial(CurrentLocationAddressInitial value),
    @required Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    @required Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    @required Result loadFailure(CurrentLocationAddressLoadFailure value),
  }) {
    assert(initial != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initial(CurrentLocationAddressInitial value),
    Result loadInProgress(CurrentLocationAddressLoadInProgress value),
    Result loadSuccess(CurrentLocationAddressLoadSuccess value),
    Result loadFailure(CurrentLocationAddressLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure(this);
    }
    return orElse();
  }
}

abstract class CurrentLocationAddressLoadFailure
    implements CurrentLocationAddressState {
  const factory CurrentLocationAddressLoadFailure() =
      _$CurrentLocationAddressLoadFailure;
}
